<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>NaN</title>
  
  <subtitle>一腔孤勇</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-05-21T15:23:23.586Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>ZHAO Zinan</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>焦距，光圈， 景深以及最短对焦距离的原理解释 —— 来自摄影小白的刨根问底</title>
    <link href="http://yoursite.com/2019/05/21/camera-introduction-physics/"/>
    <id>http://yoursite.com/2019/05/21/camera-introduction-physics/</id>
    <published>2019-05-21T05:28:59.000Z</published>
    <updated>2019-05-21T15:23:23.586Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.ibb.co/gzYXfFC/photo-1512790182412-b19e6d62bc39-ixlib-rb-1-2.jpg" style="width:80%">作为一只摄影小白（甚至还没有自己的相机），在<a href="https://twitter.com/hi_yggd?lang=en" target="_blank" rel="noopener">@yggd</a>的撺掇之下看完果核的<a href="https://sspai.com/post/54753" target="_blank" rel="noopener">这篇</a>入门文章后，终于对一些摄影中基本的术语有了了解。虽然那篇入门文章十分图文并茂简单易懂全方位介绍了初步接触摄影时需要了解的大部分术语操作， 但我一只理科汪还是对某些诸如 “一般来说，焦段越长，最短距离越长” 等事实性的描述产生了疑惑。于是本文就在yggd的鼓励之下诞生了， 意在用理科生熟悉的思路对果核的摄影入门文章进行解释补充。</p><p><a id="more"></a></p><h2>术语</h2><h3>焦距</h3><p>照相的过程可以简化为凸透镜成像的过程。</p><p><img src="https://i.ibb.co/KmfSzTg/camera-photo-063610ef-3467-45c1-9aa2-ef6c1ef5277a.png" alt=""></p><p>左边的人可以视为我们想要拍摄的物体，右边则是过度简化的相机模型——把镜头简化为一块凸透镜，而最右边的竖线则是相机底片的位置。如果想要清晰的照片，成像的位置要在底片附近。 焦距与物距，相距的关系可以由以下公式确定：</p><p>$$ \frac{1}{u} + \frac{1}{v} = \frac{1}{f} $$</p><p>u为物距（要拍的物体到镜头的距离），v为相距（镜头到在相机中成的像的距离），而f为凸透镜焦距（如果完全不记得自己学过这么个玩意儿也没有关系，毕竟我也不记得，记住就好， 之后关系推导会用到）。</p><p>焦距为凸透镜本身的一种属性， 不会改变， 但是由于相机镜头是由多片凸透镜和凹透镜组成， 我们可以通过改变某些镜片的位置来改变整个相机镜头的焦距。 这就是变焦镜头<strong>变焦（zoom）</strong> 的过程。</p><h3>光圈</h3><p><img src="https://i.ibb.co/60qCXw8/3f39291b6d99d8498358c72c087033a0.jpg" alt=""></p><p>光圈则通过改变光线进入相机内部时通过的孔径来调整进入相机镜头的光线强度。光圈越小， 拍出的照片越暗这一点很容易理解——半掩的盒子总会比敞开的盒子暗些。 但神奇的是， 光圈改变的同时也会影响景深。 具体原因会在下一节进行解释。</p><h2>焦距，光圈对于景深以及对焦距离的影响</h2><h3>焦距之于对焦距离</h3><blockquote><p>但是，要说明的是，我们可以让无穷远处非常清晰，但是不能无限近，所有镜头本身有着最近的对焦距离（一般来说，焦段越长，最短距离越长）。</p></blockquote><p>让我开始研究这些参数的起因，便是这句来自果核摄影入门中的话。焦段越长，最短距离越长，然而景深却越近，这让当时搞混了最短距离和景深概念的我彻底迷糊了。最短对间距离指的是理论上相机可以离被拍物体最近的距离，即公式$\frac{1}{u} + \frac{1}{v} = \frac{1}{f}$中，物距u可以取得的最小值。为了取得u的最小值，我们需要将v调至最大，而如果相机的焦段f越长，能取得的u的最小值便会更大。</p><h3>光圈，焦距之于景深</h3><p><img src="https://i.ibb.co/MkC7PHR/a15046f86a34841bd408f4d68e6f0b1a.gif" alt=""></p><p>景深是相机对焦点前后相对清晰的成像范围。我们在前文提到，如果想要清晰的照片，底片要尽可能在焦点的位置。但是由于人眼的鉴别能力有限，只要弥散圆的直径小于某一特定值，我们看到的都是清晰的物体。而这两个清晰度极限点之间的距离， 就是景深（即图中的焦深）。</p><p><img src="https://i.ibb.co/hXsx4sD/image.png" alt=""></p><p>这幅图展示了光圈对于景深的影响，图中红色的光线相对光圈更大。由于透过凸透镜的光线总是会通过焦点，我们可以看出当光圈变小， 光线之间的夹角变小， 达到人眼极限直径的弥散圆的位置会相对底片更远，也就意味着景深更大，照片中的更多部分会比较清晰。</p><p><img src="https://i.ibb.co/w4943Cn/image.png" alt=""></p><p>而如果光圈不变，焦距变大。在公式$\frac{1}{u} + \frac{1}{v} = \frac{1}{f}$中，可以认为物距不变（忽略由于调整镜头带来的微小变化），f增大， v也会随之增大，也就是成像位置（焦点）会随之后移。即从图中的红色光线变成了蓝色光线的位置，我们可以观察到类似的景深变大的现象。</p><h2>结语</h2><p>摄影小白的我写完这篇文章也很是感慨。没有什么实战经验，这篇文章对于我来说不太像是摄影原理深究，反而更像是一道初中物理题……同时由于我经验不足，如果有什么不对的地方， 欢迎指正~</p><p>总之，感谢yggd让我产生了写这篇文章的念头。希望这篇文章多少能帮助到你，也希望我能早日拥有自己的相机📷，把理论付诸实践🤣。</p><h2>Reference</h2><ol><li><a href="https://zh.wikipedia.org/zh-hk/%E6%99%AF%E6%B7%B1" target="_blank" rel="noopener">景深-维基百科</a></li><li><a href="http://www.pooher.com/xinwen/Technical/2012-11-28/251.html" target="_blank" rel="noopener">焦距、光圈和景深的关系，焦距越长，景深越长？</a></li><li><a href="https://blog.xieyc.com/depth-of-field-and-hyperfocal-distance/" target="_blank" rel="noopener">相机对焦原理（附景深与超焦距）</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://i.ibb.co/gzYXfFC/photo-1512790182412-b19e6d62bc39-ixlib-rb-1-2.jpg&quot; style=&quot;width:80%&quot;&gt;
作为一只摄影小白（甚至还没有自己的相机），在&lt;a href=&quot;https://twitter.com/hi_yggd?lang=en&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;@yggd&lt;/a&gt;的撺掇之下看完果核的&lt;a href=&quot;https://sspai.com/post/54753&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;这篇&lt;/a&gt;入门文章后，终于对一些摄影中基本的术语有了了解。虽然那篇入门文章十分图文并茂简单易懂全方位介绍了初步接触摄影时需要了解的大部分术语操作， 但我一只理科汪还是对某些诸如 “一般来说，焦段越长，最短距离越长” 等事实性的描述产生了疑惑。于是本文就在yggd的鼓励之下诞生了， 意在用理科生熟悉的思路对果核的摄影入门文章进行解释补充。&lt;/p&gt;
&lt;p&gt;
    
    </summary>
    
      <category term="others" scheme="http://yoursite.com/categories/others/"/>
    
      <category term="photography" scheme="http://yoursite.com/categories/others/photography/"/>
    
    
      <category term="life" scheme="http://yoursite.com/tags/life/"/>
    
      <category term="Chinese" scheme="http://yoursite.com/tags/Chinese/"/>
    
  </entry>
  
  <entry>
    <title>Complexity of Python Operations of Algorithm Problem Solutions</title>
    <link href="http://yoursite.com/2019/05/13/Python-Operations-Complexity-md/"/>
    <id>http://yoursite.com/2019/05/13/Python-Operations-Complexity-md/</id>
    <published>2019-05-13T13:46:58.000Z</published>
    <updated>2019-05-21T15:23:34.719Z</updated>
    
    <content type="html"><![CDATA[<p>If you have used Python, C++ and Java to solve algothm problmes, you will find some pythonic solutions in the discuss. It motivates me to write a summary of python operations complexity because of a question in zhihu <a href="https://www.zhihu.com/question/310632731" target="_blank" rel="noopener">为什么leetcode中python解法过于pythonic,而忽略了算法题主要关注的复杂度问题?</a>. This article is just a summary based on my past experience in algorithm problems solving.</p><p><a id="more"></a>It is not a good guide for people who haven't heard about the complexity of codes and data strucutres. Also be reminded that the implementation in the article is in python3 and if you run it python2, there may be some bugs.</p><h2>View the source codes</h2><p>We can use the built-in <code>inspect</code> module to inspecte the source codes of a function, which helps us a lot to analyse the complexity of a function.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># assume we want to see the source code of function foo</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> inpect </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>inpect.getsource(foo)</span><br><span class="line"><span class="comment"># return source code of foo function</span></span><br></pre></td></tr></table></figure></p><h2>Complexity of Data Structures</h2><h3>Stack</h3><p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;&gt; stack = []</span><br><span class="line"></span><br><span class="line"><span class="comment"># push</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>stack.append(<span class="number">2</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>stack.append(<span class="number">3</span>) <span class="comment"># the stack is like [2, 3]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># pop the top of stack (tail of the list)</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>stack.pop() </span><br><span class="line"><span class="comment"># 3</span></span><br></pre></td></tr></table></figure></p><p>Stack can be implemented with list in python. As the tail of a list is used as the top of the stack, the complexity of <code>push</code> and <code>pop</code> in stack will be <code>O(1)</code>.</p><h3>Queue</h3><p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># simple version with list</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>queue = []</span><br><span class="line"></span><br><span class="line"><span class="comment"># enqueue</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>queue.append(<span class="number">2</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>queue.append(<span class="number">3</span>) <span class="comment"># queue like [2, 3]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># dequeue</span></span><br><span class="line">queue.pop(<span class="number">0</span>) </span><br><span class="line"><span class="comment"># 2</span></span><br></pre></td></tr></table></figure></p><p>If we use list to implement it, the <code>enqueue</code> operation performs <code>O(1)</code> complexity as it operates on the tail of the list. But the <code>dequeue</code> takes <code>O(n)</code> complexity as it removes the first element of the list and the rest n-1 element needs to be moved one element forward.</p><p>Another better way to use queue data structure is like this:<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># queue module </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> queue</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>q = queue.Queue()</span><br><span class="line"></span><br><span class="line"><span class="comment"># enque</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line"><span class="meta">... </span>    q.put(i)</span><br><span class="line"></span><br><span class="line"><span class="comment"># deque</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>q.get()</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">while</span> <span class="keyword">not</span> q.empty():</span><br><span class="line"><span class="meta">... </span>    print(q.get(), end=<span class="string">' '</span>)</span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> </span><br><span class="line"></span><br><span class="line"><span class="comment"># deque module</span></span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line">d = deque(<span class="string">'12345'</span>)</span><br><span class="line">d.append(<span class="string">'6'</span>) <span class="comment"># deque object [1, 2, 3, 4, 5, 6]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># enque</span></span><br><span class="line">d.popleft()</span><br></pre></td></tr></table></figure></p><p>According to the <a href="https://hg.python.org/cpython/file/3.5/Modules/_collectionsmodule.c" target="_blank" rel="noopener">source code</a>, a deque is a doubly-linked list. As the <code>push</code> and <code>pop</code> operation from either side are approximately <code>O(1)</code> as long as it doesn't exceed the maximum size, the <code>deque</code> and <code>enqueue</code> operations of deque is of <code>O(1)</code> complexity. By the way, we can implement the queue with doubly-linked list by ourself as well, but it is not necessary as we have built-in <code>deque</code> module already.</p><h3>Heap / Priority Queue</h3><p>Use <code>heqpq</code> to implement a priority queue with priority. <code>(1, 'foo1')</code>: 1 is the priority and 'foo1' is the value. By default it is a minimum priority queue, we can use <code>-priority</code> to turn it into a maximum priority queue.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> heapq</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>p = []</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>heapq.heapify(p)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>heapq.heappush(p, (<span class="number">1</span>, <span class="string">'foo1'</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>heapq.heappush(p, (<span class="number">2</span>, <span class="string">'foo2'</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>p</span><br><span class="line">[(<span class="number">1</span>, <span class="string">'foo1'</span>), (<span class="number">2</span>, <span class="string">'foo2'</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>heapq.heappop(p)</span><br><span class="line">(<span class="number">1</span>, <span class="string">'foo1'</span>)</span><br></pre></td></tr></table></figure></p><p>Another way to use priority queue in Python is to use <code>Queue</code> module in Python.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> queue </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>q = queue.PriorityQueue()</span><br><span class="line"></span><br><span class="line"><span class="comment"># enque </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>q.put(<span class="number">10</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>q.put(<span class="number">1</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>q.put(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># deque</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">while</span> <span class="keyword">not</span> q.empty():</span><br><span class="line"><span class="meta">... </span>    print(q.get())</span><br><span class="line">...</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">10</span></span><br></pre></td></tr></table></figure></p><p>From the <a href="https://github.com/python/cpython/blob/e42b705188271da108de42b55d9344642170aa2b/Lib/asyncio/queues.py#L219" target="_blank" rel="noopener">source code</a>, we can know that the priority queue of <code>Queue</code> module is also implemented with <code>heapq</code> module. The complexity of <code>push</code> and <code>pop</code> methods are <code>O(n)</code> for both modules, while the initlization complexity of <code>heapify</code> is <code>O(n)</code> and that of putting elements one by one to the priority queue is <code>O(nlog(n))</code>. The difference between these two initialization methods are the same as the difference between <code>heapify</code> and <code>heapsort</code> explained in <a href="http://www.cs.toronto.edu/~krueger/cscB63h/lectures/tut02.txt" target="_blank" rel="noopener">this material</a>.</p><h3>Hash Table (dictionary) / Set</h3><p>As both dictionary and set in Python is implemented with hash table, the average case can be viewed as $O(1)$.</p><h2>To Be Continued</h2><p>This article only mentions the complexity of some data structures frequently used in Python. Hopefully, I will add some more complexity analysis of the algorithm solutions in Python in the future. Enjoy thinking~</p><h2>References</h2><ol><li><a href="https://stackoverflow.com/questions/6256983/how-are-deques-in-python-implemented-and-when-are-they-worse-than-lists#answer-6257048" target="_blank" rel="noopener">How are deques in Python Implemented, and When are They Worse than Lists?</a></li><li><a href="https://en.wikipedia.org/wiki/Hash_table#Performance_analysis" target="_blank" rel="noopener">Wikipedia Hash Tables</a></li><li><a href="https://stackoverflow.com/questions/3949310/how-is-set-implemented" target="_blank" rel="noopener">Stackoverflow: How is Set Implemented</a></li><li><a href="https://github.com/python/cpython/blob/master/Objects/setobject.c" target="_blank" rel="noopener">Set Source Code</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;If you have used Python, C++ and Java to solve algothm problmes, you will find some pythonic solutions in the discuss. It motivates me to write a summary of python operations complexity because of a question in zhihu &lt;a href=&quot;https://www.zhihu.com/question/310632731&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;为什么leetcode中python解法过于pythonic,而忽略了算法题主要关注的复杂度问题?&lt;/a&gt;. This article is just a summary based on my past experience in algorithm problems solving.&lt;/p&gt;
&lt;p&gt;
    
    </summary>
    
      <category term="programming" scheme="http://yoursite.com/categories/programming/"/>
    
      <category term="algorithm" scheme="http://yoursite.com/categories/programming/algorithm/"/>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
      <category term="English" scheme="http://yoursite.com/tags/English/"/>
    
  </entry>
  
  <entry>
    <title>Why I Decided to Write a Blog</title>
    <link href="http://yoursite.com/2019/01/28/Reasons/"/>
    <id>http://yoursite.com/2019/01/28/Reasons/</id>
    <published>2019-01-27T16:00:00.000Z</published>
    <updated>2019-05-21T15:22:25.231Z</updated>
    
    <content type="html"><![CDATA[<p>It seems that all the programmers around me have their own blogs, while I am notthe kind of people who want to share one's own life with strangers. I can write down mysadness and happiness in my journal. The technical knowledge is kept neatly in myOnenote (I won't use Evernote until it can highlight the code block).</p><p>But today when I was reading the article <a href="http://www.ruanyifeng.com/blog/2019/01/prolog.html" target="_blank" rel="noopener">prolog</a>, it hit me that it'stime to have my own blog which shares interesting things. It is not a place toshow how learned I am, but where I can be heared by the world.</p><p>I am just like a child who finds the most wonderful shells on the beach and wantsto show it to the whole world.</p><p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="string">"Hello World. Welcome to see my beautiful shells."</span>)</span><br><span class="line">Hello World. Welcome to see my beautiful shells.</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;It seems that all the programmers around me have their own blogs, while I am not
the kind of people who want to share one&#39;s own life with
      
    
    </summary>
    
      <category term="others" scheme="http://yoursite.com/categories/others/"/>
    
    
      <category term="others" scheme="http://yoursite.com/tags/others/"/>
    
  </entry>
  
</feed>
